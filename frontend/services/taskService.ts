import { Task } from '../types';
import { getCurrentUser } from './authService';

// This simulates an environment variable for the backend URL
// In a real app, this would be defined in .env
const API_URL = import.meta.env.VITE_API_URL || 'http://backend:3000/api';

// Helper to simulate network delay
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Dynamic storage key based on logged-in user to segregate data
const getStorageKey = () => {
  const user = getCurrentUser();
  return user ? `taskflow_tasks_${user.id}` : 'taskflow_tasks_guest';
};

export const getTasks = async (): Promise<Task[]> => {
  const response = await fetch(`${API_URL}/tasks`);
  if (!response.ok) {
    throw new Error('Failed to fetch tasks');
  }
  return response.json();
};

export const saveTask = async (task: Task): Promise<Task> => {
  // Check if it's an update (has ID and exists in backend) or create
  // Ideally, the UI or logic should distinguish create vs update more clearly.
  // Based on current logic, let's try to update if it looks like an existing task, 
  // but standard REST: POST for new (no ID or ID generated by server), PUT for update.
  // The frontend generates ID before saving in many React apps, or backend does.
  // Looking at TaskForm.tsx would reveal if ID is generated on client.
  // Assuming ID is present. Let's use PUT if we assume it exists, but strict REST would be:
  // POST /tasks for create, PUT /tasks/:id for update.

  // Let's implement a check or just try PUT and if 404 then POST? 
  // Or simpler: The backend I wrote supports POST for create and PUT for update.
  // The frontend `saveTask` handles both.

  // Strategy: If the task has an ID that looks like it was generated by the backend or already exists?
  // Actually, for this simple app, let's treat it as:
  // If it's an edit, the ID exists.
  // We'll use a simple heuristic: In this app, `saveTask` is called.

  // ADDED: Get current user ID to send to backend for linking
  const user = getCurrentUser();
  const taskWithUser = { ...task, userId: user?.id };

  let response = await fetch(`${API_URL}/tasks/${task.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(taskWithUser)
  });

  if (response.status === 404) {
    response = await fetch(`${API_URL}/tasks`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(taskWithUser)
    });
  }

  if (!response.ok) {
    throw new Error('Failed to save task');
  }

  return response.json();
};

export const deleteTask = async (id: string): Promise<void> => {
  const response = await fetch(`${API_URL}/tasks/${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    throw new Error('Failed to delete task');
  }
};
